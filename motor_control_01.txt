
#include <PID_v1.h>

double kp = .5, ki = 1, kd = 0; //PID variables and constants
double motorTorque; //torque in motor(PID INPUT)
double torquePedal; //torque supplied by the pedlar (from torque sensor)(PID SETPOINT)
double PWM;         //PWM(PID OUTPUT)

PID myPID(&motorTorque, &PWM, &torquePedal, kp, ki, kd, DIRECT);

float r; //constant for angular speed convertion, to use in torque calculation expression
float angSpeed; //angSpeed is angular speed of the motor, 
float V=48, I; //V and I are avg of qualtities supplied to the motor
float e,esum; //e is instantanious efficiency of motor from efficiency table

const int a_m = 0, b_m = 0, c_m = 0, A_m = 0, B_m = 0, C_m = 0; //ports for mosfet(a,b,c need PWM)
const int a_h = 0, b_h = 0,c_h = 0; //ports for hallsensor inputs
int a, b, c, A, B, C;
int hall = 0;     // holds hall sensor inputs

 // efficiency chart
float Ival[60]={};
float ASval[60]={};
float Eval[60]={};

int P[60],k,j;

void setup()
{
  //take angSpeed, V, torquePedal and I as input from appropriate pins
  
  myPID.SetMode(AUTOMATIC); // for using PID library's Compute function
  Serial.begin(9600); // just for printing Output (DEBUG only)

  pinMode(a_m, OUTPUT);  //mosfet output ports
  pinMode(b_m, OUTPUT);
  pinMode(c_m, OUTPUT);
  pinMode(A_m, OUTPUT);
  pinMode(B_m, OUTPUT);
  pinMode(C_m, OUTPUT);

  pinMode(a_h, INPUT);  //hallsensor input ports
  pinMode(b_h, INPUT);
  pinMode(c_h, INPUT);

}

void loop()
{
 k=0;
 for(j=0;j<60;j++)
 {
  if((Ival[j]-I</*value*/)&&(I-Ival[j]</*value*/))
  {
    P[k]=j;
    k++;
  }
 }
 count=k;k=0;esum=0;
 for(j=0;j<count;j++)
 {
  if((ASval[P[j]]-angSpeed</*value*/)&&(angSpeed-ASval[P[j]]</*value*/))
  {
    esum=esum+E[P[j]];
    k++;
  }
 }
 e=esum/k;
 motorTorque=V*I*e*r/angSpeed;
 
 if (myPID.Compute()){ 
    //area for testing
   }
 if (torquePedal=0)PWM=0; //takes care of case when pedal_torque=0
   
 hall=digitalRead(a_h);           // hall sensor value is stored
 hall=10*hall+digitalRead(b_h);   // in form of abc
 hall=10*hall+digitalRead(c_h);

 // switching

 if(hall==101)  //step1
  {
    a=1;A=0;b=0;B=1;c=0;C=0;
  }
 if(hall==100)  //step2
  {
    a=1;A=0;b=0;B=0;c=0;C=1;
  }
 if(hall==110)  //step3
  {
    a=0;A=0;b=1;B=0;c=0;C=1;
  }
 if(hall==010)  //step4
  {
    a=0;A=1;b=1;B=0;c=0;C=0;
  }
 if(hall==011)  //step5
  {
    a=0;A=1;b=0;B=0;c=1;C=0;
  }
 if(hall==001)  //step6
  {
    a=0;A=0;b=0;B=1;c=1;C=0;
  }

 analogWrite(a_m, 0);
 analogWrite(b_m, 0);
 analogWrite(c_m, 0);
 digitalWrite(A_m, A);
 digitalWrite(B_m, B);
 digitalWrite(C_m, C);
 if (a==1) analogWrite(a_m, PWM);
 if (b==1) analogWrite(b_m, PWM);
 if (c==1) analogWrite(c_m, PWM);

}