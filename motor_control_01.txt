

#include <PID_v1.h>

double kp = .5, ki = 1, kd = 0; //PID variables and constants    NEED TO FIND NEW VALUES(IF NEEDED)
double motorTorque; //torque in motor(PID INPUT)
double torquePedal; //torque supplied by the pedlar (from torque sensor)(PID SETPOINT)
double PWM;         //PWM(PID OUTPUT)

double inT=0,finT=0; //holds time for the function
const int pinc=/*value*/,pins=/*value*/,pinT=/*value*/,pinI=/*value*/;
int sine,cosine;

int ival;
float RPMf(ival) //function for angular speed
{
 sine=digitalRead(pins);
 cosine=digitalRead(pinc);
if(sine+cosine!=ival)                              
{                                                  
  ival=sine+cosine;
  inT=finT;                                       
  finT=millis();
  //degpsec=(90/8)/(finT-inT);
  //RPM=degpsec/360;
  return (1/(32.0*(finT-inT));
} 
else 
{
  return RPMf(sine+cosine);
}
}
//function for Tp(Pedaller torque)
int Tpf()
{
  // read the input on analog pin 1:
  int sensorValue = analogRead(pinT);
  // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V):
  float voltage = sensorValue * (5.0 / 1023.0);
  
  return (100*voltage-250);   
}


PID myPID(&motorTorque, &PWM, &torquePedal, kp, ki, kd, DIRECT);

float angSpeed; //angSpeed is angular speed of the motor, 
float V=48, I; //V and I are avg of qualtities supplied to the motor
float e,esum; //e is instantanious efficiency of motor from efficiency table

const int a_m = 0, b_m = 0, c_m = 0, A_m = 0, B_m = 0, C_m = 0; //ports for mosfet(a,b,c need PWM)    GIVE VALUES
const int a_h = 0, b_h = 0,c_h = 0; //ports for hallsensor inputs
int a, b, c, A, B, C;
int hall = 0;     // holds hall sensor inputs

 // efficiency chart
float Ival[60]={};
float ASval[60]={};
float Eval[60]={};
float Vval[60]={},vsum;

int P[60],k,j;

void setup()
{
  //take angSpeed, V, torquePedal and I as input from appropriate pins
  
  myPID.SetMode(AUTOMATIC); // for using PID library's Compute function
  Serial.begin(9600); // just for printing Output (DEBUG only)

  pinMode(a_m, OUTPUT);  //mosfet output ports
  pinMode(b_m, OUTPUT);
  pinMode(c_m, OUTPUT);
  pinMode(A_m, OUTPUT);
  pinMode(B_m, OUTPUT);
  pinMode(C_m, OUTPUT);

  pinMode(a_h, INPUT);  //hallsensor input ports
  pinMode(b_h, INPUT);
  pinMode(c_h, INPUT);

  pinMode(pins, INPUT);
  pinMode(pinc, INPUT);
  pinMode(pinT, INPUT);
  pinMode(pinT, INPUT);

}

void loop()
{
 I = analogRead(pinI);
 sine=digitalRead(pins);  
 cosine=digitalRead(pinc);   
 ival=sine+cosine;
 angSpeed=RPMf(ival);
 torquePedal= Tpf();
  //calculatin motor torque
 k=0;
 for(j=0;j<60;j++)
 {
  if((Ival[j]-I</*value*/)&&(I-Ival[j]</*value*/))                            // PUT VALUES
  {
    P[k]=j;
    k++;
  }
 }
 count=k;k=0;esum=0;vsum=0;
 for(j=0;j<count;j++)
 {
  if((ASval[P[j]]-angSpeed</*value*/)&&(angSpeed-ASval[P[j]]</*value*/))       //  PUT VALUES
  {
    esum = esum + Eval[P[j]];
    vsum = vsum + Vval[P[j]];
    k++;
  }
 }
 V = vsum/k;
 e = esum/k;
 motorTorque=V*I*e/angSpeed;
 
 if (myPID.Compute()){ 
    //area for testing
   }
 if (torquePedal=0)PWM=0; //takes care of case when pedal_torque=0
   
 hall=digitalRead(a_h);           // hall sensor value is stored
 hall=10*hall+digitalRead(b_h);   // in form of abc
 hall=10*hall+digitalRead(c_h);

 // switching

 if(hall==101)  //step1
  {
    a=1;A=0;b=0;B=1;c=0;C=0;
  }
 if(hall==100)  //step2
  {
    a=1;A=0;b=0;B=0;c=0;C=1;
  }
 if(hall==110)  //step3
  {
    a=0;A=0;b=1;B=0;c=0;C=1;
  }
 if(hall==010)  //step4
  {
    a=0;A=1;b=1;B=0;c=0;C=0;
  }
 if(hall==011)  //step5
  {
    a=0;A=1;b=0;B=0;c=1;C=0;
  }
 if(hall==001)  //step6
  {
    a=0;A=0;b=0;B=1;c=1;C=0;
  }

 analogWrite(a_m, 0);
 analogWrite(b_m, 0);
 analogWrite(c_m, 0);
 digitalWrite(A_m, A);
 digitalWrite(B_m, B);
 digitalWrite(C_m, C);
 if (a==1) analogWrite(a_m, PWM);
 if (b==1) analogWrite(b_m, PWM);
 if (c==1) analogWrite(c_m, PWM);

}